#include <std_msgs/Int32.h>
#include <hbba_msgs/RegisterExploitationMatch.h>
#include <hbba_msgs/Intention.h>
#include <std_msgs/String.h>
#include <ros/ros.h>
#include <map>
#include <vector>
#include <string>

namespace iw
{
    /// \brief A basic node that matches priority (int) values from arbitration
    /// modules to exploited desires.
    ///
    /// Exploitation matches are filtered with the latest intention output from
    /// the IW solver.
    ///  
    /// Incoming topics:
    ///  - priority: A std_msgs/Int32 input, normally remapped to arbitration
    ///    output (see abtr_priority).
    ///  - intention: A hbba_msgs/Intention used to map exploited desire classes
    ///    to desire IDs.
    ///
    /// Output topics:
    ///  - exploited_desire: A std_msgs/String message containing a desire id 
    ///    produced everytime an exploitation value is matched.
    ///
    /// Provided services:
    ///  - register: Register a int32/string[] pair.
    ///    A single priority can be matched to multiple desire classes in one
    ///    call.
    ///    Note that multiple priority values can be matched to a single desire
    ///    class, it's just registration that cannot be made in a single call.
    ///
    class ExploitationMatcher
    {
    public:
        ExploitationMatcher()
        {
            ros::NodeHandle np("~");
            sub_priority_ = n_.subscribe("priority", 10, 
                &ExploitationMatcher::priorityCB, this);
            sub_intention_ = n_.subscribe("intention", 10, 
                &ExploitationMatcher::intentionCB, this);
            pub_desire_ = 
                n_.advertise<std_msgs::String>("exploited_desire", 10);
            srv_register_ = n_.advertiseService("register",
                &ExploitationMatcher::registerCB, this);

        }

        void intentionCB(const hbba_msgs::Intention::ConstPtr& msg)
        {
            // Flush the current desire map and rebuild it from scratch.
            // Skip empty desires.
            desire_map_.clear();

            assert(msg->desires.size() == msg->desire_types.size());
            for (size_t i = 0; i < msg->desires.size(); ++i)
            {
                const std::string& d_id = msg->desires[i];
                const std::string& d_t = msg->desire_types[i];
                if (d_id != "" && d_t != "")
                {
                    DesireMapType::iterator dv = desire_map_.find(d_t);
                    if (dv == desire_map_.end())
                        dv = desire_map_.insert(
                            std::make_pair(d_t, StringVector())).first;
                    dv->second.push_back(d_id);
                }

            }


        }

        void priorityCB(const std_msgs::Int32::ConstPtr& msg)
        {
            // Find if any desire classes can be matched to the incoming
            // priority value.
            // Then, for each class found, find if any desires in the latest
            // intention are currently associated with it.
            // Publish an exploitation match for each of them, or warn the user.
            
            int priority = msg->data;
            if (priority_map_.find(priority) == priority_map_.end())
            {
                ROS_ERROR("Unknown priority value: %i", priority);
                return;
            }

            const StringVector& list = priority_map_[priority];
            typedef StringVector::const_iterator ItType;
            for (ItType i = list.begin(); i != list.end(); i++)
            {
                ROS_DEBUG("Exploitation for desire type %s.", i->c_str());
                DesireMapType::const_iterator d = desire_map_.find(*i); 
                if (d == desire_map_.end())
                {
                    // This is totally normal for priorities than can fulfill
                    // two different desires:
                    //ROS_WARN("Desire type %s can't be matched to "
                    //    "a current desire", i->c_str());
                    continue;
                }
                for (ItType j = d->second.begin(); j != d->second.end(); ++j)
                {
                    std_msgs::String msg;
                    msg.data = *j;
                    pub_desire_.publish(msg);
                }

            }

        }

        bool registerCB(hbba_msgs::RegisterExploitationMatch::Request& req,
            hbba_msgs::RegisterExploitationMatch::Response& rep)
        {
            if (priority_map_.find(req.priority) == priority_map_.end())
                priority_map_[req.priority] = StringVector();

            StringVector& list = priority_map_[req.priority];
            list.reserve(list.size() + req.classes.size());
            list.insert(list.end(), req.classes.begin(), req.classes.end());

            return true;
        }

    private:
        ros::NodeHandle n_;
        ros::Subscriber sub_priority_;
        ros::Subscriber sub_intention_;
        ros::Publisher pub_desire_;
        ros::ServiceServer srv_register_;

        typedef std::vector<std::string> StringVector;
        // The priority map can match more than one desire type per priority
        // value.
        typedef std::map<int, StringVector> PriorityMapType;
        PriorityMapType priority_map_;
        // The desires map can match more than one desire for each type.
        typedef std::map<std::string, StringVector> DesireMapType;
        DesireMapType desire_map_; 

            
            
    };
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "exploitation_matcher");
    
    iw::ExploitationMatcher node;
    ros::spin();

    return 0;
}

