#include <std_msgs/Int32.h>
#include <hbba_msgs/RegisterExploitationMatch.h>
#include <ros/ros.h>
#include <map>
#include <vector>
#include <string>

namespace iw
{
    /// \brief A basic node that matches priority (int) values from arbitration
    /// modules to exploited desire classes.
    ///
    /// Incoming topics:
    ///  - priority: A std_msgs/Int32 input, normally remapped to arbitration
    ///    output (see abtr_priority).
    ///
    /// Provided services:
    ///  - register: Register a int32/string[] pair.
    ///    A single priority can be matched to multiple desire classes in one
    ///    call.
    ///    Note that multiple priority values can be matched to a single desire
    ///    class, it's just registration that cannot be made in a single call.
    ///
    class ExploitationMatcher
    {
    public:
        ExploitationMatcher()
        {
            ros::NodeHandle np("~");
            sub_priority_ = n_.subscribe("priority", 10, 
                &ExploitationMatcher::priorityCB, this);
            srv_register_ = n_.advertiseService("register",
                &ExploitationMatcher::registerCB, this);

        }

        void priorityCB(const std_msgs::Int32::ConstPtr& msg)
        {
            int priority = msg->data;
            if (map_.find(priority) == map_.end())
            {
                ROS_ERROR("Unknown priority value: %i", priority);
                return;
            }

            const StringVector& list = map_[priority];
            typedef StringVector::const_iterator ItType;
            for (ItType i = list.begin(); i != list.end(); i++)
            {
                ROS_DEBUG("Exploitation for %s.", i->c_str());
            }

        }

        bool registerCB(hbba_msgs::RegisterExploitationMatch::Request& req,
            hbba_msgs::RegisterExploitationMatch::Response& rep)
        {
            if (map_.find(req.priority) == map_.end())
                map_[req.priority] = StringVector();

            StringVector& list = map_[req.priority];
            list.reserve(list.size() + req.classes.size());
            list.insert(list.end(), req.classes.begin(), req.classes.end());

            return true;
        }

    private:
        ros::NodeHandle n_;
        ros::Subscriber sub_priority_;
        ros::ServiceServer srv_register_;

        typedef std::vector<std::string> StringVector;
        typedef std::map<int, StringVector> MapType;
        MapType map_;

            
            
    };
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "exploitation_matcher");
    
    iw::ExploitationMatcher node;
    ros::spin();

    return 0;
}

